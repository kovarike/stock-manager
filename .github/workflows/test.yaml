name: Build for C Project

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]  # Compila em múltiplos SOs
        compiler: [gcc, clang]  # Testa com diferentes compiladores

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Cache dependencies
      uses: actions/cache@v2
      with:
        path: |
          build/
          ~/.cache
        key: ${{ runner.os }}-build-${{ hashFiles('**/Makefile') }}

    - name: Set up build environment (Linux/Mac)
      if: runner.os != 'Windows'
      run: |
        sudo apt-get update
        sudo apt-get install build-essential  # Instala gcc e make no Linux
        if [ ${{ matrix.compiler }} == 'clang' ]; then
          sudo apt-get install clang
        fi

    - name: Set up build environment (Windows)
      if: runner.os == 'Windows'
      run: |
        choco install mingw  # Instala gcc no Windows com Chocolatey

    - name: Build with ${{ matrix.compiler }}
      run: |
        make clean
        make CC=${{ matrix.compiler }}  # Substitui o compilador baseado na matriz

    # - name: Run tests
    #   run: ./tests/run_tests  # Execute o binário de testes que você configurou no Makefile

    # - name: Static analysis with cppcheck
    #   run: |
    #     if [ ${{ matrix.compiler }} == 'gcc' ]; then
    #       cppcheck --enable=all --inconclusive --error-exitcode=1 src/  # Usa cppcheck para análise estática
    #     fi

    - name: Upload binaries as artifacts
      uses: actions/upload-artifact@v2
      with:
        name: Binaries-${{ matrix.os }}-${{ matrix.compiler }}
        path: ./StockManager  # Supondo que os binários sejam gerados no diretório ./bin/

  # coverage:
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v2

  #   - name: Install gcov and lcov
  #     run: |
  #       sudo apt-get install lcov

  #   - name: Run tests with coverage
  #     run: |
  #       make clean
  #       make CC=gcc CFLAGS="--coverage"
  #       ./tests/run_tests
  #       lcov --directory . --capture --output-file coverage.info  # Gera o relatório de cobertura

  #   - name: Upload coverage report
  #     uses: actions/upload-artifact@v2
  #     with:
  #       name: Coverage Report
  #       path: coverage.info

  build-linux:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        os: [ubuntu-latest, centos-latest]  # Distribuições Linux alvo

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build binary
      run: |
        docker run --rm -v $PWD:/src -w /src ubuntu:${{ matrix.os }} bash -c "apt-get update && apt-get install -y build-essential && make"

    - name: Create installer (Linux)
      run: |
        if [ ${{ matrix.os }} == "ubuntu-latest" ]; then
          docker run --rm -v $PWD:/src -w /src ubuntu:${{ matrix.os }} bash -c "dpkg-deb --build mypackage"
        elif [ ${{ matrix.os }} == "centos-latest" ]; then
          docker run --rm -v $PWD:/src -w /src centos:${{ matrix.os }} bash -c "yum install -y rpm-build && rpmbuild -ba mypackage.spec"
        fi
    
    - name: Upload .deb/.rpm to GitHub
      uses: actions/upload-artifact@v2
      with:
        name: Linux Installers
        path: |
          *.deb
          *.rpm

  build-windows:
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build and package for Windows
      run: |
        choco install nsis -y  # Instala NSIS para criar o instalador .exe
        make  # Compila o binário no Windows
        makensis installer_script.nsi  # Gera o .exe

    - name: Upload .exe to GitHub
      uses: actions/upload-artifact@v2
      with:
        name: Windows Installer
        path: *.exe

  build-macos:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Build and package for macOS
      run: |
        make  # Compila o binário no macOS
        pkgbuild --root /path/to/app --identifier com.example.myapp --version 1.0 --install-location /Applications myapp.pkg  # Gera o .pkg
        hdiutil create -volname "MyApp" -srcfolder /path/to/app -ov -format UDZO myapp.dmg  # Gera o .dmg

    - name: Upload .dmg/.pkg to GitHub
      uses: actions/upload-artifact@v2
      with:
        name: MacOS Installers
        path: |
          *.dmg
          *.pkg

  release:
    runs-on: ubuntu-latest
    needs: [build-linux, build-windows, build-macos]  # O job de release depende dos builds
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Token para criar release
      with:
        tag_name: v1.0.0  # Defina a tag como quiser
        release_name: "Release v1.0.0"
        draft: false
        prerelease: false

    - name: Upload Release Assets
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./StockManager  # Substitua pelo caminho dos seus binários
        asset_name: StockManager  # Nome do binário
        asset_content_type: application/octet-stream

    # Faz upload dos instaladores gerados
    - name: Upload Linux Installers to Release
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: *.deb
        asset_name: Linux Installer (.deb)
        asset_content_type: application/octet-stream
        
    - name: Upload Windows Installer to Release
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: *.exe
        asset_name: Windows Installer (.exe)
        asset_content_type: application/octet-stream
        
    - name: Upload macOS Installers to Release
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: *.dmg
        asset_name: macOS Installer (.dmg)
        asset_content_type: application/octet-stream
